#include <iostream>
#define pi  3.14159265359
#define e   2.71828182846

using namespace std;

const int razmer = 256;       //максимальное кол-во значений "х" и "у"
const double epsilon = 10e-4;   //точность
const double a = 0.5;       //нижняя граница
const double b = 1;         //верхняя граница

//интегрируемая функция
double f(double x);

/*****************************************************************************************************************************************************************
*****************************************************************************************************************************************************************/

int main()
{
	
	double summa = 0;             //сигма
	double ans = 0;             //значение интеграла
	double prevAns = 0;         //предыдущее значение интеграла
	setlocale(LC_ALL, "rus");   //русский язык
	int n = 4;                  //число всех значений "х" и "у"
	double massiveX[razmer] = { 0 };  //все х
	double massiveY[razmer] = { 0 };  //все у
	double h = (b - a) / n;     //длина шага
/*****************************************************************************************************************************************************************
*****************************************************************************************************************************************************************/

//метод Симпсона
	printf("Метод Симпсона\n");

	//вывод иксов
	printf("x |");
	for (int i = 0; i < n + 1; i++)
	{
		printf("%.3lf\t|", a + i * h);
		massiveX[i] = a + i * h;
	}

	//вывод игриков
	printf("\ny |");
	for (int i = 0; i < n + 1; i++)
	{
		printf("%.3lf\t|", f(a + i * h));
		massiveY[i] = f(a + i * h);
	}

	//вычисление значения интеграла с суммой нечетных значений
	for (int i = 1; i < n; i += 2)
		summa += f(massiveX[i]);
	ans = h / 3 * (f(a) + 4 * summa + f(b));
	summa = 0;

	//вычисление значения интеграла с суммой четных значений
	for (int i = 2; i < n - 1; i += 2)
		summa += f(massiveX[i]);
	ans += h / 3 * 2 * summa;
	summa = 0;

	//вывод значения интеграла
	printf("\nS_%d = %lf\n\n", n, ans);

	//пока не достигли заданной точности
	while (abs(ans - prevAns) > epsilon)
	{
		n *= 2;         //увеличение интервала вдвое
		h /= 2;         //уменьшение шага вдвое
		prevAns = ans;  //запоминание предыдущего значения
		ans = 0;        //обнуление значения интеграла

		//вывод иксов
		printf("x |");
		for (int i = 0; i < n + 1; i++)
		{
			printf("%.3lf\t|", a + i * h);
			massiveX[i] = a + i * h;
		}

		//вывод игриков
		printf("\ny |");
		for (int i = 0; i < n + 1; i++)
		{
			printf("%.3lf\t|", f(a + i * h));
			massiveY[i] = f(a + i * h);
		}

		//вычисление значения интеграла с суммой нечетных значений
		for (int i = 1; i < n; i += 2)
			summa += f(massiveX[i]);
		ans = h / 3 * (f(a) + 4 * summa + f(b));
		summa = 0;

		//вычисление значения интеграла с суммой четных значений
		for (int i = 2; i < n - 1; i += 2)
			summa += f(massiveX[i]);
		ans += h / 3 * 2 * summa;
		summa = 0;

		//вывод значения интеграла
		printf("\nS_%d = %lf\n\n", n, ans);
	}

	//вывод погрешности
	printf("Точность составляет +-%lf\n\n", abs(ans - prevAns));

	/*****************************************************************************************************************************************************************
	*****************************************************************************************************************************************************************/

	//метод трапеций
	printf("Метод трапеций\n");

	n = 4;               //число всех значений "х" и "у"
	h = (b - a) / n;     //длина шага
	summa = 0;             //сигма
	ans = 0;             //значение интеграла
	prevAns = 0;         //предыдущее значение интеграла

	//вывод иксов
	printf("x |");
	for (int i = 0; i < n + 1; i++)
	{
		printf("%.3lf\t|", a + i * h);
		massiveX[i] = a + i * h;
	}

	//вывод игриков
	printf("\ny |");
	for (int i = 0; i < n + 1; i++)
	{
		printf("%.3lf\t|", f(a + i * h));
		massiveY[i] = f(a + i * h);
	}

	//вычисление интеграла
	summa += f(a);
	for (int i = 1; i < n; i++)
	{
		summa += 2 * f(massiveX[i]);
	}
	summa += f(b);
	ans = h / 2 * summa;

	//вывод значения интеграла
	printf("\nS_%d = %lf\n\n", n, ans);

	while (abs(ans - prevAns) > epsilon)
	{
		n += 4;              //число всех значений "х" и "у"
		h = (b - a) / n;     //длина шага
		summa = 0;             //сигма
		prevAns = ans;       //предыдущее значение интеграла
		ans = 0;             //значение интеграла

		//вывод иксов
		printf("x |");
		for (int i = 0; i < n + 1; i++)
		{
			printf("%.3lf\t|", a + i * h);
			massiveX[i] = a + i * h;
		}

		//вывод игриков
		printf("\ny |");
		for (int i = 0; i < n + 1; i++)
		{
			printf("%.3lf\t|", f(a + i * h));
			massiveY[i] = f(a + i * h);
		}

		//вычисление интеграла
		summa += f(a);
		for (int i = 1; i < n; i++)
		{
			summa += 2 * f(massiveX[i]);
		}
		summa += f(b);
		ans = h / 2 * summa;

		//вывод значения интеграла
		printf("\nS_%d = %lf\n\n", n, ans);
	}

	//вывод погрешности
	printf("Точность составляет +-%lf\n\n", abs(ans - prevAns));

	/*****************************************************************************************************************************************************************
	*****************************************************************************************************************************************************************/

	//метод прямоугольников
	printf("Метод прямоугольников\n");

	n = 4;               //число всех значений "х" и "у"
	h = (b - a) / n;     //длина шага
	summa = 0;             //сигма
	ans = 0;             //значение интеграла
	prevAns = 0;         //предыдущее значение интеграла

	//вывод иксов
	printf("x |");
	for (int i = 0; i < n; i++)
	{
		printf("%.3lf\t|", a + i * h);
		massiveX[i] = a + i * h;
	}

	//вывод игриков
	printf("\ny |");
	for (int i = 0; i < n; i++)
	{
		printf("%.3lf\t|", f(a + i * h));
		massiveY[i] = f(a + i * h);
	}

	//вычисление интеграла
	for (int i = 0; i < n; i++)
	{
		summa += f(massiveX[i]);
	}
	ans = h * summa;

	//вывод значения интеграла
	printf("\nS_%d = %lf\n\n", n, ans);

	while (abs(ans - prevAns) > epsilon)
	{
		n += 4;              //число всех значений "х" и "у"
		h = (b - a) / n;     //длина шага
		summa = 0;             //сигма
		prevAns = ans;         //предыдущее значение интеграла
		ans = 0;             //значение интеграла

		//вывод иксов
		printf("x |");
		for (int i = 0; i < n; i++)
		{
			printf("%.3lf\t|", a + i * h);
			massiveX[i] = a + i * h;
		}

		//вывод игриков
		printf("\ny |");
		for (int i = 0; i < n; i++)
		{
			printf("%.3lf\t|", f(a + i * h));
			massiveY[i] = f(a + i * h);
		}

		//вычисление интеграла
		summa += f(a);
		for (int i = 1; i < n; i++)
		{
			summa += 2 * f(massiveX[i]);
		}
		summa += f(b);
		ans = h / 2 * summa;

		//вывод значения интеграла
		printf("\nS_%d = %lf\n\n", n, ans);
	}

	//вывод погрешности
	printf("Точность составляет +-%lf\n\n", abs(ans - prevAns));

	system("pause>>void");
	return 0;
}

/*****************************************************************************************************************************************************************
*****************************************************************************************************************************************************************/

//интегрируемая функция
double f(double x)
{
	return exp(pow(x,-3));
}