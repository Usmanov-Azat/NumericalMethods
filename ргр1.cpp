#include <iostream> //ввод/ввывод
#include <fstream>  //файловые потоки

using namespace std;    //простарнство имен

//фнкция для того , чтобы поменять два значения в массиве местами
void swap(double* elem_1, double* elem_2);

//функция поиска максимума
double maximum(double elem_1, double elem_2);

//основная программа









int main()
{
	setlocale(LC_ALL, "rus");       //русский язык

	ifstream file("text.txt");      //открытие файла для чтения матрицы

	double gaus[3][4];              //матрица для метода гаусса
	double iterations[3][5] = { 0 };      //матрица для метода простых итераций
	double k, x, y, z;              //коэффициент и неизвестные
	double newX, newY, newZ;        //новые значения неизвестных , чтобы не затирать сразу предыдущие
	double epsilon;                     //точность
	double delta;                   //норма разности векторов
	double normaVec;                //норма вектора свободных значений в методе простых итераций
	double norma;                   //минимальная норма
	double tempMass[3];             //временный массив
	double norma_1 = 0, norma_2 = 0;//две нормы матрицы
	char xyz[] = { 'x','y','z' };   //символьный массив коэффициентов

/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

//Метод Гаусса
	
	
	
	
	
	
	
	
	
	cout << "\tИсходная система:\n\t";  //печать исходной системы
	for (size_t i = 0; i < 3; i++)
	{
		for (size_t j = 0; j < 3; j++)
		{
			file >> gaus[i][j];                     //запись значений из файла в матрицу
			iterations[i][j] = gaus[i][j];                //такая же запись в массив для метода простых итераций
			printf("%.2lf%c ", gaus[i][j], xyz[j]); //вывод матрицы
		}
		file >> gaus[i][3];                 //запись свободного значения
		iterations[i][3] = gaus[i][3];            //то же самое
		printf("= %.2lf\n\t", gaus[i][3]);  //вывод свободных значений
	}
	system("pause");


	cout << "\n\tРешение методом Гаусса\t";
	for (size_t i = 0; i < 2; i++)
	{
		k = gaus[i + 1][0] / gaus[0][0];        //вычисления коэффициента для преобразования матрицы
		for (size_t j = 0; j < 4; j++)
		{
			gaus[i + 1][j] -= gaus[0][j] * k;   //избавление от коэффициента при х во 2 и 3 строках
		}
	}



	cout << "\n\tПреобразования матрицы:\n\t";
	for (size_t i = 0; i < 3; i++)
	{
		for (size_t j = 0; j < 4; j++)
			printf("%.2lf ", gaus[i][j]);   //вывод матрицы
		cout << "\n\t";
	}

	k = gaus[2][1] / gaus[1][1];        //вычисления коэффициента
	for (size_t j = 1; j < 4; j++)
		gaus[2][j] -= gaus[1][j] * k;   //окончание приведения к треугольному виду



	cout << "\n\t";
	for (size_t i = 0; i < 3; i++)
	{
		for (size_t j = 0; j < 4; j++)
			printf("%.2lf ", gaus[i][j]);   //вывод матрицы
		cout << "\n\t";
	}



	//вывод полученной системы в форматированном виде (с x,y,z)
	cout << "\n\tПолученная система:\n\t";
	for (size_t i = 0; i < 3; i++)
	{
		for (size_t j = 0; j < 3; j++)
			printf("%.2lf%c ", gaus[i][j], xyz[j]);
		printf("= %.2lf\n\t", gaus[i][3]);
	}

	//нахождение x,y,z
	z = gaus[2][3] / gaus[2][2];
	y = (gaus[1][3] - gaus[1][2] * z) / gaus[1][1];
	x = (gaus[0][3] - gaus[0][2] * z - gaus[0][1] * y) / gaus[0][0];

	//вывод полученных значений
	printf("\n\tz = %.2lf , y = %.2lf , x = %.2lf\n\n\t", z, y, x);

	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	system("pause");

	//Метод простых итераций
	cout << "Решение методом простых итераций\n\t";
	cout << "Образуем слева вектор неизвестных:\n\t";
	for (size_t i = 0; i < 3; i++)
		for (size_t j = 0; j < 3; j++)
		{
			if (i == j) continue;
			iterations[i][j] = -iterations[i][j];   //замена коэффициентов на противоположные , будто их перенесли в правую сторону
		}

	for (size_t i = 0; i < 3; i++)
	{
		for (size_t j = 0; j < 3 - i; j++)
		{
			swap(iterations[i][4 - j], iterations[i][3 - j]);   //сдвиг значений с конца (как бы перенос с левой части в правую)
		}
		for (size_t j = 0; j < i; j++)
		{
			swap(iterations[i][i], iterations[i][j]);   //перенос искомой неизвестной в левую сторону (в 1-ой строке х , во 2-ой у , в 3-ей z)
		}
	}



	//вывод системы с перенесенными коэффициентами в формаированном виде (с x,y,z)
	for (size_t i = 0; i < 3; i++)
	{
		printf("%.2lf%c = ", iterations[i][0], xyz[i]);
		for (size_t j = 1; j < 4; j++)
			printf("%.2lf%c ", iterations[i][j], xyz[j - 1]);
		printf("%.2lf\n\t", iterations[i][4]);
	}

	//деление на первый член
	cout << "\n\tВывод строк разделенных на коэффициенты неизвестных , стоящих слева:\n\t";
	for (size_t i = 0; i < 3; i++)
	{
		k = iterations[i][0]; //коэффициент для деления 
		for (size_t j = 0; j < 5; j++)
		{
			iterations[i][j] /= k;    //само деление
		}

		//вывод в форматированном виде , как только что было вверху
		printf("%.2lf%c = ", iterations[i][0], xyz[i]);
		for (size_t j = 1; j < 4; j++)
			printf("%.2lf%c ", iterations[i][j], xyz[j - 1]);
		printf("%.2lf\n\t", iterations[i][4]);
	}

	//вычисление нормы матрицы
	for (size_t i = 0; i < 3; i++)
	{
		tempMass[i] = 0;    //обнуление элементов массива
		for (size_t j = 1; j < 4; j++)
		{
			tempMass[i] += abs(iterations[i][j]); //суммирование элементов матрицы по строкам и по модулю
		}
	}
	for (size_t i = 0; i < 2; i++)
		norma_1 = maximum(abs(tempMass[i]), abs(tempMass[i + 1]));  //сравнение всех сумм и выбор максимума

	for (size_t i = 1; i < 4; i++)
	{
		tempMass[i - 1] = 0;    //обнуление элементов
		for (size_t j = 0; j < 3; j++)
		{
			tempMass[i - 1] += abs(iterations[j][i]); //суммирование элементов матрицы по столбцам и по модулю
		}
	}
	for (size_t i = 1; i < 3; i++)
		norma_2 = maximum(abs(tempMass[i - 1]), abs(tempMass[i]));  //сравнение всех сумм и выбор максимума

	norma = (norma_1 < norma_2) ? norma_1 : norma_2;            //выбор минимальной нормы из двух

	//проверка на сходимость
	if (norma > 1)
	{
		cout << "\n\tНорма больше 1 , поэтому метод не будет сходится к точному решению!\n\n\t";
		system("pause");
		return 0;
	}

	normaVec = maximum(maximum(abs(iterations[0][4]), abs(iterations[1][4])), abs(iterations[2][4]));     //норма вектора свободных значений

	x = iterations[0][4]; //задание начального х
	y = iterations[1][4]; //задание начального у
	z = iterations[2][4]; //задание начального z
	k = 1;          //номер итерации и степень для нормы матрицы

	epsilon = 1;    //точность

	//проведение итераций до необходимой точности и вывод таблицы
	cout << "\n\tВывод таблицы результатов по итерациям\n\t";
	cout << "№\tx\t\ty\t\tz\t\te\tdelta\n\t";
	printf("%.0lf\t%.4lf\t\t%.4lf\t\t%.4lf\n\t", k, x, y, z);
	while (epsilon > 10e-3)
	{
		newX = iterations[0][2] * y + iterations[0][3] * z + iterations[0][4];
		newY = iterations[1][1] * x + iterations[1][3] * z + iterations[1][4];
		newZ = iterations[2][1] * x + iterations[2][2] * y + iterations[2][4];

		delta = maximum(maximum(abs(x - newX), abs(y - newY)), abs(z - newZ));

		x = newX;
		y = newY;
		z = newZ;

		epsilon = pow(norma, k++) * normaVec / (1 - norma);

		printf("%.0lf\t%.4lf\t\t%.4lf\t\t%.4lf\t\t%.3lf\t%.4lf\n\t", k, x, y, z, epsilon, delta);
	}

	system("pause>>void");
}

/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

//фнкция для того , чтобы поменять два значения в массиве местами
void swap(double* elem_1, double* elem_2)
{
	double temp = *elem_1;
	*elem_1 = *elem_2;
	*elem_2 = temp;
}

//функция поиска максимума
double maximum(double elem_1, double elem_2)
{
	return (elem_1 > elem_2) ? elem_1 : elem_2;
}