#include <iostream> //ввод/ввывод
#include <fstream>  //файловые потоки

using namespace std;    //простарнство имен

//фнкция для того , чтобы поменять два значения в массиве местами
void swap(double* elem_1, double* elem_2);

//функция поиска максимума
double maximum(double elem_1, double elem_2);

//форматированный вывод массива
void formatOutput(double zeid[4][6]);

//основная программа
int main()
{
	setlocale(LC_ALL, "rus");       //русский язык

	ifstream file("input.txt");     //открытие файла для чтения матрицы


	double normaVec;                //норма вектора свободных значений в методе простых итераций
	double norma;                   //минимальная норма
	double tempMass[4];             //временный массив
	double norma_1 = 0, norma_2 = 0;//две нормы матрицы
	double mass[4][4];              //массив для метода прогонки
	double zeidel[4][6] = { 0 };      //массив для метода Зейделя
	double newX[4];                 //вектор новых значений переменных
	double P[5] = { 0 };            //прогоночные коэффициенты P
	double Q[5] = { 0 };            //прогоночные коэффициенты Q
	double ans[4];                  //массив точных значений
	double k;                       //коэффициент
	double epsilon;                     //точность
	double raznica;                   //норма разности векторов
/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

//Метод прогоночных коэффициентов
	mass[0][0] = 0; //коэффициент а_1 = 0
	mass[3][3] = 0; //коэффициент с_4 =0

	//запись в первую строку массива значения из файла
	for (size_t i = 1; i < 4; i++)
		file >> mass[0][i];

	//запись в массив строк между первой и последней
	for (size_t i = 1; i < 3; i++)
	{
		for (size_t j = 0; j < 4; j++)
		{
			file >> mass[i][j];
		}
	}

	//запись в массив последней строки
	for (size_t i = 0; i < 3; i++)
		file >> mass[3][i];
	swap(mass[3][2], mass[3][3]); //свободное значение должно стоять в конце , а с_4 = 0 , поэтому меняем их местами

	//вывод системы в форматированном виде (всё что в фигурных скобках)
	{
		cout << "\tРешение методом прогонки\n";
		cout << "\tИсходная система:\n\t";  //печать исходной системы
		for (size_t i = 1; i < 3; i++)
			printf("%c%.2lfx%d\t", (mass[0][i] < 0) ? '-' : '+', abs(mass[0][i]), i);
		printf("= %c%.2lf\n\t", (mass[0][3] < 0) ? '-' : '+', abs(mass[0][3]));

		for (size_t i = 1; i < 3; i++)
		{
			for (size_t j = 0; j < 3; j++)
			{
				printf("%c%.2lfx%d\t", (mass[i][j] < 0) ? '-' : '+', abs(mass[i][j]), j + i);
			}
			printf("= %c%.2lf\n\t", (mass[i][3] < 0) ? '-' : '+', abs(mass[i][3]));
		}

		for (size_t i = 0; i < 2; i++)
			printf("%c%.2lfx%d\t", (mass[3][i] < 0) ? '-' : '+', abs(mass[3][i]), i + 3);
		printf("= %c%.2lf\n\n\t", (mass[3][3] < 0) ? '-' : '+', abs(mass[3][3]));
	}

	//вывод таблицы коэффициентов a,b,c
	cout << "Коэффициенты\n\t";
	printf("№\ta\tb\tc\n\t");
	for (size_t i = 0; i < 4; i++)
	{
		printf("%d\t%.2lf\t%.2lf\t%.2lf\n\t", i, mass[i][0], mass[i][1], mass[i][2]);
	}

	//вывод таблицы прогоночных коэффициентов
	cout << "\n\tТаблица прогоночных коэффициентов:\n\t";
	cout << "№\tP\tQ\n\t";
	for (size_t i = 0; i < 4; i++)
	{
		printf("%d\t%.2lf\t%.2lf\n\t", i, P[i], Q[i]);                                  //вывод значений
		P[i + 1] = -mass[i][2] / (mass[i][1] + mass[i][0] * P[i]);                      //формула -c / (b + a * P_i-1)
		Q[i + 1] = (mass[i][3] - mass[i][0] * Q[i]) / (mass[i][1] + mass[i][0] * P[i]); //формула (d - a * Q_i-1) / (b + a * P_i-1)
	}
	printf("%d\t%.2lf\t%.2lf\n\n\t", 4, P[4], Q[4]);    //вывод поледней строки

	//вычисление значений
	cout << "Значения переменных:\n\t";
	ans[3] = Q[4];  //последняя переменная равна последнему прогоночному коэффициенту Q
	for (int i = 2; i >= 0; i--)
		ans[i] = Q[i + 1] + P[i + 1] * ans[i + 1];  //х = Q + P * x_i+1

	//вывод найденных значений
	for (size_t i = 0; i < 4; i++)
		printf("x%d = %lf\n\t", i + 1, ans[i]);

	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	//метод Зейделя
	file.seekg(0, ios::beg);    //возвращение в начало файла

	/*запись значений из файла в массив с 1 ячейки диагональным видом, например
		0   8x1     -2x2    11.4        0       0
		0   -1x1    6x2     -2x3        5.7     0
		0   0       2x2     10x3        -4x4    15.2
		0   0       0       -1x3        6x4     9.5
	*/
	for (size_t j = 1; j < 4; j++)
		file >> zeidel[0][j];
	for (size_t i = 1; i < 3; i++)
		for (size_t j = i; j < 4 + i; j++)
			file >> zeidel[i][j];
	for (size_t j = 3; j < 6; j++)
		file >> zeidel[3][j];

	cout << "\n\tРешение методом Зейделя\n\t";
	cout << "Образуем слева вектор неизвестных:\n\t";

	//меняем местами нули из 1 столбца со значениями х1 в 1 строке, х2 во второй...
	for (size_t i = 0; i < 4; i++)
		swap(zeidel[i][i + 1], zeidel[i][0]);

	//отправляем свободные значения в конец строк
	for (size_t i = 3; i < 5; i++)
		swap(zeidel[i - 3][i], zeidel[i - 3][5]);

	for (size_t i = 0; i < 4; i++)
		for (size_t j = 1; j < 5; j++)
			zeidel[i][j] = -zeidel[i][j];   //замена коэффициентов на противоположные , будто их перенесли в правую сторону

	//вывод системы с перенесенными коэффициентами в формаированном виде
	formatOutput(zeidel);

	//деление на первый член
	cout << "\n\tВывод строк разделенных на коэффициенты неизвестных , стоящих слева:\n\t";
	for (size_t i = 0; i < 4; i++)
	{
		k = zeidel[i][0]; //коэффициент для деления 
		for (size_t j = 0; j < 6; j++)
		{
			zeidel[i][j] /= k;    //само деление
		}
	}

	//вывод в форматированном виде , как только что было вверху
	formatOutput(zeidel);

	//вычисление нормы матрицы
	for (size_t i = 0; i < 4; i++)
	{
		tempMass[i] = 0;    //обнуление элементов массива
		for (size_t j = 1; j < 5; j++)
		{
			tempMass[i] += abs(zeidel[i][j]); //суммирование элементов матрицы по строкам и по модулю
		}
	}
	for (size_t i = 0; i < 3; i++)
		norma_1 = maximum(abs(tempMass[i]), abs(tempMass[i + 1]));  //сравнение всех сумм и выбор максимума

	for (size_t i = 1; i < 5; i++)
	{
		tempMass[i - 1] = 0;    //обнуление элементов
		for (size_t j = 0; j < 4; j++)
		{
			tempMass[i - 1] += abs(zeidel[j][i]); //суммирование элементов матрицы по столбцам и по модулю
		}
	}
	for (size_t i = 0; i < 3; i++)
		norma_2 = maximum(abs(tempMass[i]), abs(tempMass[i + 1]));  //сравнение всех сумм и выбор максимума

	norma = (norma_1 < norma_2) ? norma_1 : norma_2;            //выбор минимальной нормы из двух

	//проверка условия сходимости
	if (norma > 1)
	{
		cout << "\n\tНорма больше 1 , поэтому метод не будет сходится к точному решению!\n\n\t";
		system("pause");
		return 0;
	}

	//норма вектора свободных коэффициентов
	for (size_t i = 0; i < 3; i++)
		normaVec = maximum(abs(zeidel[i][5]), abs(zeidel[i + 1][5]));

	//запись первых значений неизвестных элементами вектора свободных значений
	for (size_t i = 0; i < 4; i++)
		ans[i] = zeidel[i][5];

	epsilon = 1;    //точность
	k = 1;      //итерация

	//проведение итераций до необходимой точности и вывод таблицы
	cout << "\n\tВывод таблицы результатов по итерациям\n\t";
	cout << "№\tx1\t\tx2\t\tx3\t\tx4\t\te\tdelta\n\t";
	printf("%.0lf\t%.4lf\t\t%.4lf\t\t%.4lf\t\t%.4lf\n\t", k, ans[0], ans[1], ans[2], ans[3]);
	while (epsilon > 0.01)
	{
		newX[0] = zeidel[0][1] * ans[0] + zeidel[0][2] * ans[1] + zeidel[0][3] * ans[2] + zeidel[0][4] * ans[3] + zeidel[0][5];
		newX[1] = zeidel[1][1] * newX[0] + zeidel[1][2] * ans[1] + zeidel[1][3] * ans[2] + zeidel[1][4] * ans[3] + zeidel[1][5];
		newX[2] = zeidel[2][1] * newX[0] + zeidel[2][2] * newX[1] + zeidel[2][3] * ans[2] + zeidel[2][4] * ans[3] + zeidel[2][5];
		newX[3] = zeidel[3][1] * newX[0] + zeidel[3][2] * newX[1] + zeidel[3][3] * newX[2] + zeidel[3][4] * ans[3] + zeidel[3][5];

		for (size_t i = 0; i < 3; i++)
		{
			raznica = maximum(abs(ans[i] - newX[i]), abs(ans[i + 1] - newX[i + 1]));
			ans[i] = newX[i];
		}
		ans[3] = newX[3];

		epsilon = pow(norma, k++) * normaVec / (1 - norma); // ||B||^k * ||b|| / (1 - ||B||)

		printf("%.0lf\t%.4lf\t\t%.4lf\t\t%.4lf\t\t%.4lf\t\t%.3lf\t%.4lf\n\t", k, ans[0], ans[1], ans[2], ans[3], epsilon, raznica);
	}

	system("pause");
}

/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

//фнкция для того , чтобы поменять два значения в массиве местами
void swap(double* elem_1, double* elem_2)
{
	double temp = *elem_1;
	*elem_1 = *elem_2;
	*elem_2 = temp;
}

//функция поиска максимума
double maximum(double elem_1, double elem_2)
{
	return (elem_1 > elem_2) ? elem_1 : elem_2;
}

void formatOutput(double zeid[4][6])
{
	for (size_t i = 0; i < 4; i++)
	{
		printf("%.2lfx%d\t=\t", zeid[i][0], i + 1);
		for (size_t j = 1; j < 5; j++)
			printf("%c%.2lfx%d\t", (zeid[i][j] < 0) ? '-' : '+', abs(zeid[i][j]), j);
		printf("%c%.2lf\n\t", (zeid[i][5] < 0) ? '-' : '+', abs(zeid[i][5]));
	}
}