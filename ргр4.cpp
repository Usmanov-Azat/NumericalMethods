#include <iostream> //ввод/ввывод
#include <fstream>  //файловые потоки
#include <cmath>    //математическая библиотека

#define M_PI    3.1415926535898 //число пи
#define begin   0.2             //левая граница
#define end     2               //правая граница

using namespace std;    //простарнство имен

//заданная функция
double f(double x);

//производная функции f(x)
double f_d(double x);

//2-я производная функции f(x)
double f_d_d(double x);

//равносильная функция x = g(x)
double g(double x);

//производная функции g(x)
double g_d(double x);

//основная программа
int main()
{
	setlocale(LC_ALL, "rus");   //русский язык

	ifstream file("input.txt"); //открытие файла для чтения матрицы

	double eps = 1e-2;          //точность 0.01 , т.е. 10^-2
	double a = begin;           //левая граница
	double b = end;             //правая граница
	double c;                   //текущая точка
	double oldC;                //предыдущая точка
	char flag;                  //флаг

/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

//Метод дихотомического поиска
	cout << "\tМетод дихотомического поиска\n";
	cout << "\ta\tc\tb\tf(a)\tf(c)\tf(c)\n\t";

	//пока разность границ больше eps (b всегда больше a поэтому модуль не нужен)
	while (b - a > eps)
	{
		c = (b + a) / 2;    //вычисляем с как середину отрезка

		//заполнение таблицы значений
		printf("%.4lf\t%.4lf\t%.4lf\t%.4lf\t%.4lf\t%.4lf\n\t", a, c, b, f(a), f(c), f(b));

		//если знаки в "а" и "с" не равны то правая граница b переносится в точку с иначе наоборот
		if (f(a) * f(c) < 0)
			b = c;
		else
			a = c;
	}

	//вывод корня
	printf("\n\tx = %lf\n\n\t", c);

	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	//метод хорд
	//возвращаем границы в исходное положение
	a = begin;
	b = end;

	cout << "\tМетод хорд\n";
	cout << "\ta\tc\tb\tf(a)\tf(c)\tf(c)\n\t";

	//с = точке пересечения секущей и оси х
	c = (a * f(b) - b * f(a)) / (f(b) - f(a));

	//заполнение таблицы значений
	printf("%.4lf\t%.4lf\t%.4lf\t%.4lf\t%.4lf\t%.4lf\n\t", a, c, b, f(a), f(c), f(b));

	//если знаки в "а" и "с" не равны то правая граница b переносится в точку с иначе наоборот
	if (f(a) * f(c) < 0)
	{
		b = c;
		flag = 1;   //метод сходится односторонне, поэтому чтобы не считать каждый раз значение функции определяем направление движение в помощью флага (1 - влево иначе вправо)
	}
	else
	{
		a = c;
		flag = 0;
	}

	//запоминаем предыдущее значение с и считаем новое
	oldC = c;
	c = (a * f(b) - b * f(a)) / (f(b) - f(a));

	//пока разность двух точек или значение функции по модулую больше с считаем
	while (abs(c - oldC) > eps || abs(f(c)) > eps)
	{
		//заполнение таблицы значений
		printf("%.4lf\t%.4lf\t%.4lf\t%.4lf\t%.4lf\t%.4lf\n\t", a, c, b, f(a), f(c), f(b));

		//так же двигаем границу , как и когда поставили флаг
		if (flag)   b = c;
		else        a = c;

		//запоминаем предыдущее значение с и считаем новое
		oldC = c;
		c = (a * f(b) - b * f(a)) / (f(b) - f(a));
	}

	//вывод корня
	printf("\n\tx = %lf\n\n\t", c);

	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	//метод касательных
	oldC = (f(begin) * f_d_d(begin) > 0) ? begin : end; //выбираем начальную точку\предыдущее значение с
	c = oldC - f(oldC) / f_d(oldC);                     //считаем с
	b = 0;                                              //теперь b будет счетчиком итераций

	cout << "\tМетод касательных\n";
	cout << "\tn\ta_n-1\t\tf(a_n-1)\tf'(a_n-1)\tf''(a_n-1)\ta_n\n\t";

	//пока значение в точке по модулю больше точности
	while (abs(f(c)) > eps)
	{
		//заполнение таблицы значений
		printf("%.0lf\t%.4lf\t\t%.4lf\t\t%.4lf\t\t%.4lf\t\t%.4lf\n\t", b++, oldC, f(oldC), f_d(oldC), f_d_d(oldC), c);

		oldC = c;                       //запоминаем с
		c = oldC - f(oldC) / f_d(oldC); //считаем новое с
	}

	//вывод корня
	printf("\n\tx = %lf\n\n\t", c);

	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	//метод итераций
	oldC = (abs(g_d(begin)) < 1) ? begin : end; //выбираем начальную точку\предыдущее значение с
	c = g(c);                                   //считаем с
	b = 0;                                      //обнуляем счетчик

	cout << "\tМетод итераций\n";
	cout << "\t№\tx\tf(x)\t\tg(x)\tg'(x)\n\t";

	//пока разность c_n и c_n-1 в квадрате деленное на разность 2c_n-1 и 2c_n по модулю или значение функции в точке больше eps
	while ((c - oldC) * (c - oldC) / (abs(2 * oldC - 2 * c)) > eps || abs(f(c)) > eps)
	{
		//заполнение таблицы значений
		printf("%.0lf\t%.4lf\t%.4lf\t\t%.4lf\t%.4lf\n\t", b++, c, f(c), g(c), g_d(c));

		oldC = c;   //запоминаем с
		c = g(c);   //считаем новое с
	}

	//вывод корня
	printf("\n\tx = %lf\n\n\t", c);

	//системная пауза
	system("pause");
}

/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

//заданная функция
double f(double x)
{
	return pow(2.0, x)* x - 1;
}

//производная функции f(x)
double f_d(double x)
{
	return pow(2.0, x)* (x * log(2) + 1);
}

//2-я производная функции f(x)
double f_d_d(double x)
{
	return pow(2.0, x)* log(2)* (x * log(2) + 2);
}

//равносильная функция x = g(x)
double g(double x)
{
	return 1.0 / pow(2.0, x);
}

//производная функции g(x)
double g_d(double x)
{
	return -pow(1.0 / 2, x) * log(2);
}
